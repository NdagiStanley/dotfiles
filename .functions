#!/usr/bin/env bash

# Create a new directory and enter it
mkd() {
  mkdir -p "$@"
  cd "$@" || exit
}

nd() {
  if [ -z "$1" ]; then
    echo "Usage: $0 <script_file> [argument]"
    exit
  fi

  script=$1
  arg=$2

  if [ -z "$arg" ]; then
    node "$script.js"
  else
    node "$script.js" "$arg"
  fi
}

server() {
  python3 -m http.server "$@"
}

# `tre` is a shorthand for `tree` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.
tre() {
  tree -aC -I '.git|node_modules|bower_components' --dirsfirst "$@" | less -FRNX
}

compare() {
  hub compare "${1:=develop}"..."$(git rev-parse --abbrev-ref HEAD)"
}

compare_branch() {
  hub compare ${1:="$@"}..."$(git rev-parse --abbrev-ref HEAD)"
}

# Call from a local repo to open the repository on github/bitbucket in browser
# Modified version of https://github.com/zeke/ghwd
repo() {
  # Figure out github repo base URL
  local base_url
  base_url=$(git config --get remote.origin.url)
  base_url=${base_url%\.git} # remove .git from end of string

  # Fix git@github.com: URLs
  base_url=${base_url//git@github\.com:/https:\/\/github\.com\/}

  # Fix git://github.com URLS
  base_url=${base_url//git:\/\/github\.com/https:\/\/github\.com\/}

  # Fix git@bitbucket.org: URLs
  base_url=${base_url//git@bitbucket.org:/https:\/\/bitbucket\.org\/}

  # Fix git@gitlab.com: URLs
  base_url=${base_url//git@gitlab\.com:/https:\/\/gitlab\.com\/}

  echo $base_url

  # Validate that this folder is a git folder
  if ! git branch 2>/dev/null 1>&2; then
    echo "Not a git repo!"
    exit $?
  fi

  # Find current directory relative to .git parent
  full_path=$(pwd)
  git_base_path=$(
    cd "./$(git rev-parse --show-cdup)" || exit 1
    pwd
  )
  relative_path=${full_path#$git_base_path} # remove leading git_base_path from working directory

  # If filename argument is present, append it
  if [ "$1" ]; then
    relative_path="$relative_path/$1"
  fi

  echo $relative_path
  # Figure out current git branch
  # git_where=$(command git symbolic-ref -q HEAD || command git name-rev --name-only --no-undefined --always HEAD) 2>/dev/null
  git_where=$(command git name-rev --name-only --no- undefined --always HEAD) 2>/dev/null

  # Remove cruft from branchname
  branch="${git_where#refs\/heads\/}"
  branch="${git_where#remotes\/origin\/}"
  branch="${branch#tags\/}"
  branch="${branch%^0}"

  [[ $base_url == *bitbucket* ]] && tree="src" || tree="tree"
  url="$base_url/$tree/$branch$relative_path"

  echo "Calling $(type open) for $url"

  open "$url" &>/dev/null || (echo "Using $(type open) to open URL failed." && exit 1)
}

todo() {
  ag --color-line-number '1;36' --color-path '1;36' --ignore-case --print-long-lines --silent '(?:<!-- *)?(?:#|//|/\*+|<!--|--) *(TODO|FIXME|FIX|BUG|UGLY|HACK|NOTE|IDEA|REVIEW|DEBUG|OPTIMIZE)(?:\([^(]+\))?:?(?!\w)(?: *-->| *\*/|(?= *(?:[^:]//|/\*+|<!--|@|--))|((?: +[^\n@]*?)(?= *(?:[^:]//|/\*+|<!--|@|--))|(?: +[^@\n]+)?))'
}

# Normalize `open` across Linux, macOS, and Windows.
# This is needed to make the `o` function (see below) cross-platform.
if [ ! "$(uname -s)" = 'Darwin' ]; then
  if grep -q Microsoft /proc/version; then
    # Ubuntu on Windows using the Linux subsystem
    alias open='explorer.exe'
  else
    alias open='xdg-open'
  fi
fi

# `o` with no arguments opens the current directory, otherwise opens the given
# location
o() {
  if [ $# -eq 0 ]; then
    open .
  else
    open "$@"
  fi
}

path_audit() {
  echo "\033[1;34m=== PATH PRIORITY AUDIT ===\033[0m"

  # Iterate over the unique 'path' array
  local i=1
  for entry in $path; do
    if [ -d "$entry" ]; then
      # Check if this is a high-priority shim folder
      if [[ "$entry" == *".pyenv/shims"* ]]; then
        echo " $i. \033[1;32m$entry\033[0m (Pyenv Shims)"
      elif [[ "$entry" == *".nvm"* ]]; then
        echo " $i. \033[1;33m$entry\033[0m (Node Manager)"
      else
        echo " $i. $entry"
      fi
    else
      # Highlight dead paths in RED
      echo " $i. \033[1;31m$entry\033[0m [DOES NOT EXIST - REMOVE ME]"
    fi
    ((i++))
  done

  echo "\033[1;34m===========================\033[0m"
  echo "Total paths: ${#path[@]}"
}

dev_info() {
  echo "\n\033[1;34m=== DEVELOPMENT ENVIRONMENT DASHBOARD ===\033[0m"

  # 1. PYTHON (Pyenv & Pipx)
  if command -v pyenv >/dev/null; then
    echo "\n\033[1;33m[PYTHON]\033[0m"
    echo "  Version:  $(pyenv version --bare | tr '\n' ' ')"
    echo "  Location: $(which python3)"
    echo "  Cheats:   pyenv install (-l) | pyenv global <version> | pyenv local <version>"
  fi

  if command -v pipx >/dev/null; then
    echo "  Pipx:     Available (pipx ensurepath | pipx install <package>)"
  fi

  # 2. JAVASCRIPT (Node, NVM, PNPM, Bun)
  echo "\n\033[1;33m[JAVASCRIPT]\033[0m"
  if type nvm >/dev/null 2>&1 || command -v node >/dev/null; then
    # Check if Node is actually loaded or just lazy-shimmed
    if command -v node >/dev/null; then
      echo "  Node:     $(node -v)"
    else
      echo "  Node:     (Lazy Loaded - Run 'nvm' or 'node' to initialize)"
    fi
    echo "  Cheats:   nvm ls | nvm install --lts | nvm use <version>"
  fi

  if command -v pnpm >/dev/null; then
    echo "  PNPM:     $(pnpm --version)"
  fi

  if command -v bun >/dev/null; then
    echo "  Bun:      $(bun --version)"
  fi

  if command -v nuxi >/dev/null; then
    echo "  Nuxt:     nuxi init <project>"
  fi

  # 3. RUBY (Rbenv)
  if command -v rbenv >/dev/null; then
    echo "\n\033[1;33m[RUBY]\033[0m"
    echo "  Version:  $(rbenv global)"
    echo "  Cheats:   rbenv install -l | rbenv global <version>"
  fi

  # 4. RUST (Cargo)
  if command -v cargo >/dev/null; then
    echo "\n\033[1;33m[RUST]\033[0m"
    echo "  Version:  $(cargo --version | awk '{print $2}')"
    echo "  Cheats:   rustup update | cargo build | cargo run"
  fi

  # 5. GOLANG
  if command -v go >/dev/null; then
    echo "\n\033[1;33m[GOLANG]\033[0m"
    echo "  Version:  $(go version | awk '{print $3}')"
  fi

  # 6. JAVA
  if [ -n "$JAVA_HOME" ]; then
    echo "\n\033[1;33m[JAVA]\033[0m"
    echo "  Home:     $JAVA_HOME"
    echo "  Switch:   java21 | java25 | javalts"
  fi

  echo "\n\033[1;34m=========================================\033[0m"
}

ids() {
  echo "\n\033[1;34m=== BUNDLE IDS ===\033[0m"
  find /Applications -maxdepth 2 -name "*.app" -exec mdls -name kMDItemCFBundleIdentifier -raw {} \; -exec echo " : {}" \;
}
